TODO [prefix_breaks_pages]: (D) bug: The site seems broken when a server prefix is defined

TODO [persistent_and_cache]: (C) feature: Persistent mode, with configurable config directory.
For instance, if a `-p` flag or something (decide details later) is given,
gitwood should create a directory at $GITWOOD_DATADIR (default: `~/.gitwood`),
which should include:
* cache/ : _JSON file containing previously extracted / generated data._
* repos  : _List of repos that should be served_

NOTE [persistent_and_cache]: Cache filename format can look like this:
    filename = sha256sum(projectPath + '@' + commitHash + '@' + operationDetails)[:8]
because path, hash and operation (details) fully identifies the data of interest.
With operationDetails, I mean the name of the operation in case of listings,
and name + identifier (like filename and line number) for a single resource.

NOTE [persistent_and_cache]: Cache might be inevitable for more complex features.
To avoid having to maintain a different set of features for the persistent and non-persistent modes
because of missing cache in the latter,,
cache should _always_ be generated and stored in memory,
so the only difference between the persistent and in-memory modes will be that persistent writes cache to disk and tries to read it back on startup.
In-memory cache can be implemented with a `map[string]any`,
where the key is the hash / filename generated as described above.

TODO [operation_timeout]: feature: Background (cache generating) jobs.
Do heavy operations in the background and wait for a limited time.
Some operations may search through a large amount of repo files,
and therefore take more time than the user is willing to wait.
All such operations should generate cache so that the next attempt won't be as heavy.
To ensure that the cache is generated, the operation should run in a new go routine,
and the request handler should wait for a limited time before responding with an info page,
e.g. "The server needs some more time to find the data [Try again]".
-
This should be kept in mind when implementing #persistent_and_cache:
* Need to avoid the same cache being generated multiple times
* Requests shouldn't get data prematurely, i.e. before the cache has been generated
A possible solution is to add a channel to the cache map,
which is what the request handler should wait for.
When data is generated, cache function writes to the channel and sets it to nil.
-
So for a handler to read from cache, the cache channel must be nil,
otherwise the handler must wait for the channel or timeout.

TODO [todo_details_page]: (B) feature: Todo details page.
In gitwood, a todo for a certain repository is fully identified by these parameters:
* commit (hash or ref)
* filename
* line number
The todo page handler finds the given file for the given commit and starts reading details from subsequent lines.
Exactly what subsequent lines are treated as todo details depends on the context.
imp_subseq_line_detection talks more about that.

NOTE [todo_details_page]: In addition to reading all the details about the Todo,
find any mentions of it in the active commit, using its ID.
Mentions should come in two forms: _plain) and _note_.
Plain mentions are all lines that simply contain the Todo ID,
while _notes_ are on the format `NOTE [<todo_id>]: <contents>`.
In the Todo details page, mentions will look similar to Git{hub,lab}'s issue mentions,
e.g. `mentioned in <filename>#<line>`, which will link to the file and line num
(ideally link to associated todos eventually, but that's more complex, also see todo_references).

NOTE [todo_details_page]: Support Markdown for todo details too?
With [gomarkdown](https://github.com/gomarkdown/markdown) this should be fairly easy,
but don't spend time on it until the todo page is working fine otherwise.

TODO [todo_sort_and_filter]: feature: Add inputs for sorting and filtering todo list. 

TODO [todo_search]: feature: Free text search for todos
This should search in todo details too, so it kinda depends on caching to avoid repeating such a heavy operation.
[fuzzysearch](https://github.com/lithammer/fuzzysearch) is worth considering.

TODO [file_search]: feature: Free text search for file names.
Similar to todo_search.

TODO [todo_references]: feature: Link to other todos, like it works in issues on Github and the like.
To make it easier to parse, use the `#` prefix just like all other Git services do.
This feature requires the list of todos for the active commit,
so if it doesn't exist, a cache job (see #persistent_and_cache) should be triggered and waited for,
maybe a second max.
If cache job doesn't finish in time, links will simply not be generated before the page is returned (best effort)

TODO [todo_use_id_mapping]: Always refer to todo by ID instead of filename + line num.
In addition to making it easier to implement #todo_references,
the new mapping from Todo ID to Todo makes it easy to implement this.
The advantage of referring to Todos by ID instead of file + line is that the
link to a Todo stays the same across commits, even if the source file changes.
-
Maybe use a path param instead of query params too, so that the link looks like
`/gitwood/-/todo/todo_use_id_mapping`, which is slightly more user friendly.

TODO [support_submodules]: feature (local): Support submodules, both in requests and autoregistry.
Mostly relevant for local (non-bare) git repos, not on servers.

TODO [live_staging_mode]: feature (local): Add support for viewing todos in new changes and staging.
Not requiring a commit to see rendered todos can help eliminate formatting mistakes.
Consider making `live` an alternative to a ref or commit hash when viewing todos.

TODO [idea_dump]: Idea dump
Don't want to fill up the todo list with stuff that are not priority,
so this todo acts as an idea dump.

NOTE [idea_dump]: Ability to overwrite the default web pages:
Here's how it can work:
* User runs command `gitwood -fs templates/ [-live]`
* If `-live`: gitwood tries to (re)load pages from disk for every request
* Otherwise: gitwood tries to load pages on startup only,
  and stores the pages found in memory instead of the embedded pages
In both cases, when a page is not defined, gitwood will fall back on the
embedded default page.

TODO [static_generator]: Static page generator.
This project started as an alternative to [stagit](https://codemadness.org/stagit.html),
i.e. a static git page generator.
gitwood now serves content dynamically instead, but it should be able to do both.
_The scope will be limited to the minimal work required to avoid any broken pages_,
at least for starters.
