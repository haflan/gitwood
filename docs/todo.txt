TODO [prefix_breaks_pages]: (D) bug: The site seems broken when a server prefix is defined

TODO [persistent_and_cache]: (C) feature: Persistent mode, with configurable config directory.
For instance, if a `-p` flag or something (decide details later) is given,
gitwood should create a directory at $GITWOOD_DATADIR (default: `~/.gitwood`),
which should include:
---
* cache/ : _JSON file containing previously extracted / generated data._
* repos  : _List of repos that should be served_

NOTE [persistent_and_cache]: Cache filename format can look like this:
    filename = sha256sum(projectPath + '@' + commitHash + '@' + operationDetails)[:8]
because path, hash and operation (details) fully identifies the data of interest.
With operationDetails, I mean the name of the operation in case of listings,
and name + identifier (like filename and line number) for a single resource.

NOTE [persistent_and_cache]: Cache might be inevitable for more complex features.
To avoid having to maintain a different set of features for the persistent and non-persistent modes
because of missing cache in the latter,
cache should _always_ be generated and stored in memory,
so the only difference between the persistent and in-memory modes will be that persistent writes cache to disk and tries to read it back on startup.
---
In-memory cache can be implemented with a `map[string]any`,
where the key is the hash / filename generated as described above.

NOTE [persistent_and_cache]: One reason this is high priority is that,
in addition to making gitwood faster,
it will make it possible to decide which repos should be available.


TODO [operation_timeout]: feature: Background (cache generating) jobs.
Do heavy operations in the background and wait for a limited time.
Some operations may search through a large amount of repo files,
and therefore take more time than the user is willing to wait.
All such operations should generate cache so that the next attempt won't be as heavy.
To ensure that the cache is generated, the operation should run in a new go routine,
and the request handler should wait for a limited time before responding with an info page,
e.g. "The server needs some more time to find the data [Try again]".  
This should be kept in mind when implementing #persistent_and_cache:
* Need to avoid the same cache being generated multiple times
* Requests shouldn't get data prematurely, i.e. before the cache has been generated
A possible solution is to add a channel to the cache map,
which is what the request handler should wait for.
When data is generated, cache function writes to the channel and sets it to nil.  
So for a handler to read from cache, the cache channel must be nil,
otherwise the handler must wait for the channel or timeout.

TODO [todo_sort_and_filter]: feature: Add inputs for sorting and filtering todo list. 

TODO [todo_search]: feature: Free text search for todos
This should search in todo details too, so it kinda depends on caching to avoid repeating such a heavy operation.
[fuzzysearch](https://github.com/lithammer/fuzzysearch) is worth considering.

TODO [file_search]: feature: Free text search for file names (and contents?).
Similar to #todo_search.
After implementing server-side fuzzy search,
the list of files can be split into pages of 50 or so files each.

TODO [todo_references]: feature: Link to other todos, like it works in issues on Github and the like.
To make it easier to parse, use the `#` prefix just like all other Git services do.
This feature requires the list of todos for the active commit,
so if it doesn't exist, a cache job (see #persistent_and_cache) should be triggered and waited for,
maybe a second max.
If cache job doesn't finish in time, links will simply not be generated before the page is returned (best effort)

TODO [support_submodules]: feature (local): Support submodules, both in requests and autoregistry.
Mostly relevant for local (non-bare) git repos, not on servers.

TODO [live_staging_mode]: feature (local): Add support for viewing todos in new changes and staging.
Not requiring a commit to see rendered todos can help eliminate formatting mistakes.
Consider making `live` an alternative to a ref or commit hash when viewing todos.

TODO [idea_dump]: Idea dump
Don't want to fill up the todo list with stuff that are not priority,
so this todo acts as an idea dump.

NOTE [idea_dump]: Ability to overwrite the default web pages:
Here's how it can work:
* User runs command `gitwood -fs templates/ [-live]`
* If `-live`: gitwood tries to (re)load pages from disk for every request
* Otherwise: gitwood tries to load pages on startup only,
  and stores the pages found in memory instead of the embedded pages
In both cases, when a page is not defined, gitwood will fall back on the
embedded default page.

TODO [static_generator]: Static page generator.
This project started as an alternative to [stagit](https://codemadness.org/stagit.html),
i.e. a static git page generator.
gitwood now serves content dynamically instead, but it should be able to do both.
_The scope will be limited to the minimal work required to avoid any broken pages_,
at least for starters.

TODO [repo_descriptions]: Read the 'description' file in each repo and use as one-line description

TODO [formal_todo_spec]: Specify issue-like todos "formally"
It's easier to make the parser when the format is specified clearly.
Maybe look some more for similar ideas before writing it.
I've already found:
---
* [todo.txt](https://github.com/todotxt/todo.txt):
  For General (non-dev) todo lists, but worth considering as inspiration.
* https://conventionaltodos.org/: The entire project is a todo atm ;)
---
How the format looks determines how complex the parser implementation will be.
It's worth considering a _simple_ parser because that might lead to better TODOs,
in addition to being easier to implement.


TODO [extract_details_immediately]: Extract todo details immediately.
Extracting details from subsequent lines is not that heavy an operation.
No reason to do it in a separate step.
Merge `Extract` and `ExtractFull` and just find everything immediately?
Launching a new Go routine for each TODO found might be a good idea,
although it will of course require some kind of joining before the final struct (and JSON) is built.
---
Finding _mentions_, as discussed in #todo_details_page,
should probably still be a separate operation that's done when the full todo is requested.

TODO [cleanup_path_handling]: Clean up path handling.
All handling of paths (in links) need a thorough rewriting - no more ad-hoc solutions.
There are still some links that don't work as intended, e.g. breadcrumbs.
---
Introduce a `PageContext.generateLink()` function,
which creates link with the right query params etc.
based on current query params and target operation,
e.g. keep the commit parameter if it's set and is relevant for the target.
